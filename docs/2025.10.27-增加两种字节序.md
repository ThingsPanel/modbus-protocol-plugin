# 增加两种字节序

## 一、需求背景

当前 Modbus 插件仅支持大端（BIG）和小端（LITTLE）两种字节序，无法满足部分设备的特殊字节序要求。需要新增两种字节序模式以支持更多设备类型。

## 二、字节序类型说明

以 32 位数据（占用 2 个寄存器，4 个字节）为例：

| 字节序类型 | 常用简称 | 寄存器顺序 | 字节顺序 | 说明 |
|-----------|---------|-----------|----------|------|
| Big Endian（已实现） | ABCD | [寄存器1][寄存器2] | [Byte1 Byte2][Byte3 Byte4] | 标准大端，高字节在前 |
| Little Endian（已实现） | DCBA | [寄存器2][寄存器1] | [Byte4 Byte3][Byte2 Byte1] | 标准小端，低字节在前 |
| Byte Swap（待实现） | BADC | [寄存器1][寄存器2] | [Byte2 Byte1][Byte4 Byte3] | 寄存器顺序不变，每个寄存器内字节交换 |
| Word Swap + Byte Swap（待实现） | CDAB | [寄存器2][寄存器1] | [Byte3 Byte4][Byte1 Byte2] | 寄存器顺序和字节都交换 |

## 三、功能范围

### 3.1 影响的数据类型

新字节序仅对多寄存器数据类型生效：
- int32、uint32（占 2 个寄存器）
- float32（占 2 个寄存器）
- int64（占 4 个寄存器）
- float64（占 4 个寄存器）

**不影响的数据类型：**
- int16、uint16（单寄存器，使用默认处理）
- coil（位类型，不涉及字节序）

### 3.2 影响的功能点

1. **读数据响应解析**
   - tp_config/command_raw.go 的 Serialize 方法
   - 根据字节序正确解析响应数据

2. **写数据命令生成**
   - tp_config/command_raw.go 的 GetWriteCommand 方法
   - 根据字节序正确编码写入数据

### 3.3 不影响的部分

- Modbus 请求报文中的地址和数量字段（固定按协议标准）
- CRC 校验（RTU 固定小端）
- MBAP 头（TCP 固定大端）

## 四、实现要点

### 4.1 代码修改位置

1. **modbus/master_command.go**
   - 扩展 EndianessType 常量定义
   - 新增：ByteSwap = "BADC"
   - 新增：WordByteSwap = "CDAB"

2. **tp_config/command_raw.go**
   - 修改 Serialize 方法的数据解析逻辑
   - 修改 GetWriteCommand 方法的数据编码逻辑
   - 针对 int32/uint32/float32/int64/float64 类型处理新字节序

3. **form_config.json**
   - 在字节序选项中增加两个新选项：
     - label: "字节交换（BADC）"，value: "BADC"
     - label: "字寄存器交换（CDAB）"，value: "CDAB"

### 4.2 字节序转换逻辑

**Byte Swap (BADC)：**
- 先按大端读取整体数据
- 对每个 2 字节寄存器内部做字节反转

**Word Swap + Byte Swap (CDAB)：**
- 先交换寄存器顺序
- 每个寄存器保持原字节顺序

### 4.3 兼容性处理

- 对不支持新字节序的数据类型（int16/uint16/coil），自动使用默认处理
- 不做错误提示，确保向下兼容
- 已有配置不受影响，继续使用 BIG 或 LITTLE

## 五、测试验证

需要验证以下场景：
1. 多寄存器数据类型的读取解析（int32/uint32/float32/int64/float64）
2. 多寄存器数据类型的写入编码
3. 单寄存器数据类型的兼容性（int16/uint16）
4. 不同字节序配置的正确性
5. 已有配置的向下兼容性

# modbus模块结构分析

## 一、模块概述

modbus 插件实现了标准 Modbus 协议的 TCP 和 RTU 两种通信模式，支持数据采集、设备控制和数据转换功能。

## 二、核心模块组成

### 2.1 modbus 包 - 协议层

**文件组成：**
- `master_command.go` - 通用 Modbus 命令封装
- `tcp_command.go` - TCP 协议专用命令
- `rtu_command.go` - RTU 协议专用命令
- `utils.go` - CRC16 校验工具
- `modbus_gateway_device.go` - 网关设备结构（已注释）
- `modbus_sub_device.go` - 子设备结构（已注释）

**设计特点：**

1. **命令结构分层**
   - MasterCommand：通用命令结构，包含从站地址、功能码、起始地址、数量、字节序等
   - TCPCommand：嵌入 MasterCommand，增加 MBAP 头（事务ID、协议ID、长度）
   - RTUCommand：嵌入 MasterCommand，增加 CRC 校验

2. **字节序支持**
   - 当前支持：BIG（大端）和 LITTLE（小端）
   - 字节序仅影响请求报文的地址和数量字段的编码方式

3. **功能码支持**
   - 读功能：0x01（线圈）、0x02（输入位）、0x03（保持寄存器）、0x04（输入寄存器）
   - 写功能：0x05（单线圈）、0x06（单寄存器）、0x0F（多线圈）、0x10（多寄存器）

4. **命令序列化**
   - MasterCommand 负责核心序列化逻辑
   - TCPCommand 在此基础上添加 MBAP 头
   - RTUCommand 在此基础上添加 CRC 校验

5. **响应解析**
   - TCPCommand：校验 MBAP 头的协议ID和长度，剥离头部返回 PDU
   - RTUCommand：校验 CRC，验证数据长度，剥离 CRC 返回数据

### 2.2 tp_config 包 - 配置与数据解析层

**文件组成：**
- `command_raw.go` - 命令配置和数据解析
- `sub_device_form_config.go` - 子设备表单配置

**CommandRaw 结构职责：**

1. **配置管理**
   - 存储功能码、起始地址、数量、字节序
   - 存储采集周期、数据类型
   - 存储数据标识符、转换公式、小数位数

2. **写命令生成**
   - 根据读功能码映射写功能码（0x01→0x05、0x03→0x06）
   - 根据数据类型和索引计算写入地址
   - 根据字节序编码写入数据

3. **响应数据解析**
   - 检查异常响应
   - 根据字节序解析多字节数据类型
   - 根据数据类型解析：int16/uint16（2字节）、int32/uint32/float32（4字节）、int64/float64（8字节）、coil（位）
   - 应用转换公式（支持跨字段计算）
   - 格式化小数位数

4. **数据类型支持**
   - 线圈：coil（占1个地址）
   - 整数：int16、uint16（占1个地址）、int32、uint32（占2个地址）、int64（占4个地址）
   - 浮点：float32（占2个地址）、float64（占4个地址）

### 2.3 form_config.json - 前端配置表单

定义了用户配置界面的字段：
- 功能码选择（01/02/03/04）
- 采集周期（秒）
- 起始地址（十进制，从0开始）
- 读取数量
- 数据类型（需与功能码匹配）
- 字段标识（逗号分隔）
- 数值转换公式（可选）
- 小数位数（可选）
- 字节序（BIG/LITTLE）

## 三、数据流转流程

### 3.1 读数据流程

1. **配置加载**：从 form_config 解析用户配置，创建 CommandRaw 对象
2. **命令构建**：根据协议类型创建 TCPCommand 或 RTUCommand
3. **请求序列化**：调用 Serialize() 生成完整报文
4. **发送接收**：通过网络发送请求，接收响应
5. **响应解析**：调用 ParseTCPResponse 或 ParseAndValidateResponse 校验并剥离协议头
6. **数据解析**：CommandRaw.Serialize() 解析数据值
7. **数据转换**：应用公式和小数位格式化
8. **返回结果**：返回 map[string]interface{} 格式数据

### 3.2 写数据流程

1. **命令生成**：CommandRaw.GetWriteCommand() 根据字段和值生成写参数
2. **命令构建**：创建带写数据的 TCPCommand 或 RTUCommand
3. **请求序列化**：生成完整写报文
4. **发送接收**：发送写请求，接收响应确认

## 四、字节序当前实现

### 4.1 已实现字节序

| 类型 | 描述 | 实现位置 |
|------|------|----------|
| BIG | 大端序（高字节在前）| MasterCommand.Serialize()、CommandRaw.Serialize() |
| LITTLE | 小端序（低字节在前）| 同上 |

### 4.2 字节序作用范围

**请求报文（MasterCommand.Serialize）：**
- 起始地址字段（2字节）
- 数量字段（2字节）
- 写数据字段

**响应解析（CommandRaw.Serialize）：**
- 多字节数据类型的解析（int16/uint16/int32/uint32/float32/float64）

**特殊说明：**
- CRC 校验固定使用小端序（Modbus RTU 标准）
- MBAP 头固定使用大端序（Modbus TCP 标准）

## 五、待扩展字节序模式

需要新增支持两种字节序：

| 类型 | 寄存器顺序 | 字节顺序 | 说明 |
|------|-----------|----------|------|
| Byte Swap | [寄存器1][寄存器2] | [Byte2 Byte1][Byte4 Byte3] | 每个寄存器内字节交换 |
| Word Swap + Byte Swap | [寄存器2][寄存器1] | [Byte3 Byte4][Byte1 Byte2] | 寄存器顺序和字节都交换 |

**实现要点：**
1. 仅对多寄存器数据类型生效（int32/uint32/float32/int64/float64）
2. 需同时修改写命令生成和响应解析逻辑
3. 单寄存器数据类型（int16/uint16）不受影响
